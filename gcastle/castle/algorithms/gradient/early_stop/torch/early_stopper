from typing import Any
import numpy as np

# inspired by answers on : https://stackoverflow.com/questions/71998978/early-stopping-in-pytorch

class EarlyStopper:
    def __init__(self, patience=1, min_delta=0, window=10):
        self.patience = patience
        self.min_delta = min_delta
        self.counter = 0
        self.min_validation_loss = np.inf
        self._early_stop = False
        self.window = window
        self._loss_history = []

    def __call__(self, validation_loss):
        if validation_loss is not None:
            self.loss_history_append(validation_loss)
            self._early_stop = self.check_early_stop()
        else:
            return self._early_stop # if validation_loss is None, return early_stop status

    @property
    def early_stop(self):
        return self._early_stop

    @property
    def loss_history(self):
        return self._loss_history

    def loss_history_append(self, loss):
        self._loss_history.append(loss)
    
    @loss_history.setter
    def loss_history(self, loss_history):
        self._loss_history = loss_history

    @loss_history.deleter
    def loss_history(self):
        del self._loss_history

    def __earlyStopCriterionMin(self) -> bool:
        """
        Early stop criterion for convergence test.
        """
        if len(self._loss_history) >= self.window:
            return np.allclose(
                self._loss_history[-self.window :],
                self._loss_history[-1],
                atol=self._loss_history[-1] / 100,
            )
        else:
            return False

    def __earlyStopCriterionSat(self) -> bool:
        """
        Early stop criterion for convergence test.
        """
        if len(self._loss_history) >= 2 * self.window:
            return np.isclose(
                np.mean(self._loss_history[-self.window :]),
                np.mean(self._loss_history[-2 * self.window : -self.window]),
                atol=self._loss_history[-1] / 100,
            )
        else:
            return False
    
    def check_early_stop(self):
        if self.__earlyStopCriterionMin() or self.__earlyStopCriterionSat():
            return True
        else:
            return False
    
    def early_stop_fun(self, validation_loss):
        self.loss_history_append(validation_loss)
        if validation_loss < self.min_validation_loss:
            self.min_validation_loss = validation_loss
            if self.check_early_stop():
                pass
            else:
                self.counter = 0
        elif self.check_early_stop():
            self.counter += 1
        elif validation_loss > (self.min_validation_loss + self.min_delta):
            self.counter += 1
            if self.counter >= self.patience:
                return True
        return False
